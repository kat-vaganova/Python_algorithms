# 2. Написать два алгоритма нахождения i-го по счёту простого числа.
# Функция нахождения простого числа должна принимать на вход натуральное
# и возвращать соответствующее простое число. Проанализировать скорость и сложность алгоритмов.
# Первый — с помощью алгоритма «Решето Эратосфена».
# Примечание. Алгоритм «Решето Эратосфена» разбирался на одном из прошлых уроков.
# Используйте этот код и попробуйте его улучшить/оптимизировать под задачу.
# Второй — без использования «Решета Эратосфена».
# Примечание. Вспомните классический способ проверки числа на простоту.
# Пример работы программ:
# >>> sieve(2)
# 3
# >>> prime(4)
# 7
# >>> sieve(5)
# 11
# >>> prime(1)
# 2
# Примечание по профилированию кода: для получения достоверных результатов
# при замере времени необходимо исключить/заменить функции print() и input() в анализируемом коде.
# С ними вы будете замерять время вывода данных в терминал и время,
# потраченное пользователем, на ввод данных, а не быстродействие самого алгоритма.

# при использовании решета Эратосфена
# прцесс подсчета при больших значенниях занимает примерно такое же количество времени что и при малях
# в ином варианте расчет с большими величинами затягивается.


# решето Эратосфена


import random

# n = random.randint(1, 1000)
# print(n)

n = 1000000
sieve = [i for i in range(n)]
sieve[1] = 0
# print(f'sieve {sieve}')

for i in range(2, n):

    if sieve[i] != 0:
        j = i * 2
        # print(f' {j}', end=' ')

        while j < n:
            sieve[j] = 0
            j += i
            # print(f'j2 {j}', end=' ')


# print(*[i for i in sieve if i != 0])

from timeit import timeit
print(timeit(number=100), 'for n =')

# 5.599998985417187e-06 for n = 100
# 5.699999746866524e-06 for n = 1000
# 5.599998985417187e-06 for n = 10000
# 5.699999746866524e-06 for n = 10000000000000000